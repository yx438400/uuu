一、mysql在cmd控制台更改密码：
  
  问题：{
	错误代码 1045
	Access denied for user 'root'@'localhost' (using password:YES)
	}

步骤如下：

  1、运行“cmd”命令窗口；

  2、切换到mysql的bin目录，如“cd C:\huanJing\mysql\bin”，回车；

  3、更改mysql密码，格式：mysqladmin -u用户名 -p旧密码 password 新密码；
         如“mysqladmin -uroot -pa password root”回车即将密码修改为“root” 
    	 上述详解见“丑丑的博客”         http://blog.sina.com.cn/s/blog_6b6db50a0100m7ot.html

************************************************************************************************************
二、cmd命令窗口开启运行mysql命令：

前提：将mydql安装的bin目录添加到环境变量：D:\mysqlApachePhp\mysql\anZhuang\bin

1：以“管理员身份”启动“cmd.exe”；
2：“net start mysql”命令启动mysql服务；
3：“mysql -u root -p”进入mysql。 
4：输入密码即进入了，即可操作mysql。

**************************************************************************************************************
 三、mysql的优化：

对mysql的优化是一个综合性的技术，主要包括以下：

	1、表的设计合理化（符合 3NF【三范式】）
		三范式（3NF）：首先符合1NF，然后才满足2NF，进一步才满足3NF。

		1NF：要求属性的列具有原子性，不可再分割；即表的列具有原子性，不可再分割。只要是关系型数据库就自动满足1NF。

		2NF：表中的纪录是唯一的，就满足2NF。通常我们设定一个主键就满足2NF。即表中不会出现两条及以上所有数据完全相同的数据
			一般主键不含业务逻辑，只是自增长。

		3NF：表中没有冗余数据。表的信息，如果能够推导出来，就不应该单独设计一个字段来存放。

	2、添加适当的索引（index【普通索引、主键索引、唯一索引unique、全文索引】）

	3、分表技术（两种：水平分割、垂直分割）

	4、读写（“写”为：增删改【delete、add、update】）分离

	5、存储过程【模块化编程，可以提高速度】
		正常php程序访问数据库是这样一个过程：首先呢，php代码访问的是dbms（数据库管理系统），然后dbcms去操作数据库
	     这中间，dbcms需要经过【编译-执行-缓存】的过程，存储过程就是把常用的一些操作封装成函数，经一次编译，以后直接拿来用就可以。
	     就是模块化编程，可以提高速度。

	6、对mysql配置的优化【配置最大并发数、调整缓存大小】
		【配置最大并发数】：打开“my.ini”文件，找到“max_connections=100”，mysql默认最大并发数为100。
		一般网站调整到1000左右，每一个并发都会开启一个线程，开到再大呢，可能就会把内存撑破。

	7、mysql服务器硬件的升级

	8、定时清除不需要的数据。定时进行碎片整理（MYISAM存储引擎必须要清）


****************************************************************************************************************
四、相关笔记：
・1、show status：显示mysql服务进程，
	 默认是“show [session] status”->当前会话的进程及状态，显示的【仅仅是针对当前窗口的操作】，关掉当前窗口，就没有了。
	“show [globla] status” -> 显示【mysql服务自启动到现在】的进程及状态。显示的是mysql自启动到现在的所有操作。

     show status like 'uptime' -> 显示mysql启动到现在的时间，
     show status like ’com_select' -> 显示查询次数，
	执行了多少次添加、删除等，可依次将上面的“com_select”改为“com_insert”、“com_delete”。
	比如我插入两条数据后，执行“show status like 'com_insert';”之后，发现得到数据 2 ；
	这时如果我关闭cmd的mysql操作窗口，再打开cmd进入mysql输入“show status like 'com_insert';”,可以得到结果为 0；
	如果我在新打开的cmd的mysql窗口输入：“show global status like 'com_insert';”,可得结果仍然为 2 。


			
     show ststus like ‘connections’ -> 显示连接数，显示连接mysql的次数。如果我新开一个cmd窗口进入mysql控制台，再执行该命令，会看到获得结果比前一次 +1 。
     show status like ‘slow_queries' -> 显示慢查询次数，
     show variables like ‘long_query_time' -> 显示mysql服务慢查询的设置时间长度，
     set long_query_time=5 -> 可将mysql服务的慢查询时间设置为5秒，

・2、“delimiter $$”,将操作mysql的结束符改为“$$”,

・3、删除自定义的函数："drop function rand_string $$"。

************************************************************************************************************************************************************
五、慢查询：默认情况下，mysql认为10秒为慢查询时间。

 show status like ‘slow_queries' -> 显示慢查询次数，
 show variables like ‘long_query_time' -> 显示mysql服务慢查询的设置时间长度，
 set long_query_time=5 -> 可将mysql服务的慢查询时间设置为5秒，

慢查询相关建表及数据操作，建temp数据库、库中建表、库中建函数、库中建存储过程

注意：数据库中如temp数据库中，可以有各种数据对象：【表、存储过程、视图、函数、触发器】。
	下面第 7 步的自定义的函数 function  rand_string 属于上面一句中的 数据对象中的函数。

1、创建部门表
mysql> create table dept(deptno mediumint unsigned not null default 0,
				dname varchar(20) not null default '',
				loc varchar(13) not null default ''
			)engine=myisam default charset=utf8;

2、创建雇员表
mysql> create table emp(empno mediumint unsigned not null default 0,    //编号
				ename varchar(20) not null default '',  //名字
				job varchar(9) not null default '',     //工作
				mgr mediumint unsigned not null default 0,//上级编号
				hiredate date not null,sal decimal(7,2) not null,//入取时间
				comm decimal(7,2) not null,		//薪水
				deptno mediumint unsigned not null default 0  //部门编号
			)engine=myisam default charset=utf8;

3、工资级别表
mysql> create table salgrade(grade mediumint unsigned not null default 0,
				losal decimal(17,2) not null,
				hisal decimal(17,2) not null
			)engine=myisam default charset=utf8;

4、执行插入表数据语句：（5个工资级别）
	insert into salgrade values(1,700,1200);
	insert into salgrade values(2,1201,1400);
	insert into salgrade values(3,1401,2000);
	insert into salgrade values(4,2001,3000);
	insert into salgrade values(5,3001,9999);

5、“delimiter $$”,将操作mysql的结束符改为“$$”,可以任意设定结束符。

6、drop function rand_string $$//删除自定义的rand_string函数；

#开启日志之后，插入函数和存储过程会出问题，需要在my.ini文件的【mysqld】模块下加入：log-bin-trust-function-creators=1


7、创建一个函数
	# rand_string(n INT)中rand_string是函数名，（n INT)表示该函数接收一个整数。

	创建函数代码：	
		create function rand_string(n INT) #/*自定义函数，形参为传递的一个整数*/
		returns VARCHAR(255) #/*该函数会返回一个字符串*/
		begin
		#/*chars_str 是定义一个变量chars_str，它的类型是varchar(100),默认值是一串字符串*/
		declare chars_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
		declare return_str varchar(255) default '';
		declare i int default 0;
		while i < n do
		set return_str=concat(return_str,substring(chars_str,floor(1+rand()*52),1));
		set i=i+1;
		end while;
		return return_str;
		end $$
	执行上面函数语句为：select rand_string(6);


中间的一个说明：dual -> 亚元表（个人理解只有一行空的表）
		执行“select rand_string(6)”-> 返回一个6位随机的字符串
		执行“select rand_string(6) from dual”-> 返回一个6位随机的字符串
		执行“select rand_string(6) from salgrade”-> 返回（与“salgrade”表行数相同数目的条数的，salgrade表有5条数据）5条6位随机的字符串
		执行“select rand_string(6) from dept” -> 返回为空（因为dept表有 0 条数据）

		执行“select rand_string(6),grade from salgrade”-> 可以看看效果

8、创建一个函数，得到一个随机的数字

		create function rand_num()
		returns int(5)
		begin
		declare i int default 0;
		set i=floor(10+rand()*50);
		return i;
		end $$

9、创建一个存储过程：(退出存储过程：先输入单引号“'”并回车，然后输入单引号分好反斜杠和c“';\c”，回车即可)
		随机添加数据  400w
		//start表示雇员的编号从哪里开始，
		//max_num表示一共放多少个雇员进去

		create procedure insert_emp(in start int(10),in max_num int(10))
		begin
		declare i int default 0;
		set autocommit=0;	#//设置为0，为阻止自动提交
		repeat			#//repeat和end repeat 之间的代码相当于在一个for循环里面
		set i=i+1;		#//i 每次增加一个：1
		insert into emp values((start+i),rand_string(6),'SALESMAN',0001,curdate(),2000,400,rand_num());
		until i=max_num		#//i 增大到一共要放入的雇员的数量就停止
		end repeat;
		commit;
		end $$

		执行这个存储过程命令：call insert_emp(100001,4000000)$$ //插入400w条数据，编号从100001开始。
		【注意】：执行上面的存储过程相表里插入数据，在此之前须先建立一张对应的emp表。

10、“delimiter ;”

11、“call insert_emp(100001,4000000);” //调用存储过程，写入emp表400w条数据。编号从100001开始，四百万条数据。

12、“set long_query_time=0.5;” //将mysql的慢查询时间设置为0.5秒

13、“show variables like 'long_query_time';” //查看mysql服务的慢查询时间

14、“select * from emp where empno=345678;” //查询一条数据从emp表

15、“show status like 'slow_queries';”  //查看mysql服务的慢查询条数

16、如何把慢查询的sql语句记录到日志中去
	①、在默认情况下是不记录到日志中去的，即默认情况下，mysql不会记录sql慢查询语句。
	    需要在启动mysql服务的时候，指定记录慢查询才可以。
	    【mysql5.5可以在my.ini指定】：bin\mysqld.exe --safe-mode --slow-query-log
	    【低版本mysql5.0可以在my.ini指定】：bin\mysqld.exe -log-slow-queries=d:/abc.log

	    我的mysql版本为：5.5。
		
		开启慢查询日志记录的详细过程如下：
	    1、先在电脑“管理”的“服务”列表中关闭mysql服务。
	    2、打开cmd命令行，切换到mysql安装的bin目录的上一级目录下，命令如下：
		d:
		cd D:\mysqlApachePhp\mysql\anZhuang
		bin\mysqld.exe --safe-mode --slow-query-log


	②、先关闭mysql服务再启动mysql服务，如果启用了慢查询，默认吧这个文件放在：my.ini文件中记录的位置
		如我的my.ini文件中这样语句：

			#Path to the database root
			datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"
			（注意：datadir文件路径不要轻易修改，与索引等是一起设置的,更改以后会出问题，索引等需要重新设置）

		那么我的记录日志就在 “C:/ProgramData/MySQL/MySQL Server 5.5/Data/”目录下 
		

	③、具体操作过程
		一：先停止mysql服务，即在电脑“管理”的“服务”列表中关闭mysql服务。

		二：切换到mysql安装的bin目录的外层：我的bin目录是：D:\mysqlApachePhp\mysql\anZhuang\bin
			cmd命令：（此时无需以管理员身份运行）
				 cd D:\mysqlApachePhp\mysql\anZhuang
				 d:
				 bin\mysqld.exe --safe-mode --slow-query-log   【--safe-mode ：安全模式；】
			上面cmd的三行命令执行后，打开“C:/ProgramData/MySQL/MySQL Server 5.5/Data/”可以看到多了一个“xxx.log”文件。

			【注】：在“my.ini”配置文件中有这样的语句：
			datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"   不可随意更改
			【可根据需要改动该配置，但是数据库的数据包括索引文件也都是在这个目录下，索引是和它存放的物理位置关联的，
				更改之后，原来的索引就失效了，原来的所有索引就需要重新建立】

				#Path to the database root
				datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"
			
			【注意】：本命令窗口可关闭。
		
		三、新开一个cmd命令窗口，进入mysql，启动mysql服务并进入mysql，此时慢查询时间默认为：1秒

			net start mysql
			mysql -u root -p

		    进行mysql的操作，当更改long_query_time的值后，一旦操作的mysql语句执行时间大于long_query_time，
			就会在 “C:/ProgramData/MySQL/MySQL Server 5.5/Data/”下面的“xxx.log”文件里面，查看到慢查询的sql语句


*********************************************************************************************************************************
六、优化问题：

一、通过explain语句可以分析：mysql如何执行你的 sql 语句的


二、索引（有四种索引：主键索引、唯一索引、全文索引、普通索引）

	1、添加索引
	   
	   1.1、主键索引添加
		概念：当一张表，把某一个列设为主键的时候，则该列就是主键索引。

		①、如：创建一张表：
		    create table aaa(id int unsigned primary key auto_increment,name char(20) not null default '');
		    这时 id列 就是主键索引。
	
		    如果创建表的时候，没有指定主键索引，也可以在创建表后再添加。指令：alter table 表名 add primary key(列名或者字段名);
			如创建一张表：create table bbb(id int,name char(20) not null default '');->创建时没有主键
			可以查看bbb表的索引：“show index from bbb\G;” -> 得到结果为空。
			
			给bbb表添加主键：“alter table bbb add primary key(id);” -> 将bbb表的字段“id”设置为主键即主键索引
			这时可以查看bbb表的索引：“show index from bbb\G;” -> 可以看到主键索引信息。
		②、例如：temp数据库中emp表是没有主键的，执行“select * from emp where empno=3456789;”可以看到执行时间为：1.04秒。
			      然后给emp表添加主键索引：执行“alter table emp add primary key(empno);”；
			      添加完主键索引以后，执行“select * from emp where empno=3456789;”可以看到执行结果的时间为：0.01秒。
		    两次前后查询速度对比，可见明显差别。

		    具体的看到文件大小变化是在“my.ini”配置文件的“datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"”目录
			下的“temp”目录下，如我的emp表数据，它分别是“emp.MYD”、“emp.MYI”、“emp.frm”三个文件
			其中：“emp.MYD”是数据库文件，当不增不删数据时，它的大小固定，400w条数据大概，他有195m的样子；
			     “emp.MYI”是索引文件，在最开始，表没建主键索引的时候，它的大小为1k，当执行建立主键索引的过程中，
					当前“temp”目录下会生成另外三个临时文件，并且大小随时变化；
					当主键索引建立完毕，“emp.MYI”文件的大小会变为几十m或者更大 ，那三个临时文件消失了。
			创建普通索引也一样。	  
	   	
	   1.2、普通索引添加
		概念：一般来说，普通索引的创建，是先创建表，然后再创建普通索引。

		语法：create index 索引名 on 表名 （列即字段名）

		比如：“create table ccc(id int,name char(20) not null default '');”，创建表完成后，我想呢将字段“id”创建为普通索引。
			可以查看ccc表的索引：“show index from ccc\G;” -> 得到结果为空。
			执行“create index cid on ccc (id);”给ccc表添加普通索引，到字段id上。
			这时可以查看ccc表的索引：“show index from ccc\G;” -> 可以看到主键索引信息,成功。

	   1.3、全文索引创建
		概念：全文索引主要针对文件、文本的检索，比如：文章；【全文索引 仅仅 针对MyISAM有效】。

		①、创建表:例如 :
				CREATE TABLE articles (
					 id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
					 title VARCHAR(200),
					 body TEXT,
  					 FULLTEXT (title,body)
				);

			这里的 “FULLTEXT (title,body)”创建全文索引不会有用；
			我在运行上面创建“articles”表的时候运行结果是：“ERROR 1214 (HY000): The used table type doesn't support FULLTEXT indexes”；
			原因是因为：目前只有myisam支持fulltext的   innodb不支持 我默认的表类型是innodb的 。
				

		      这个表需要这样创建，即在后面加上“engine=myisam”；
			如：
				CREATE TABLE articles (
					 id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
					 title VARCHAR(200),
					 body TEXT,
  					 FULLTEXT (title,body)
				)engine=myisam charset=utf8;

		②、往上面①创建的articles表里插入数据
			 INSERT INTO articles (title,body) VALUES
				 ('MySQL Tutorial','DBMS stands for DataBase ...'),
				 ('How To Use MySQL Well','After you went through a ...'),
				 ('Optimizing MySQL','In this tutorial we will show ...'),
				 ('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
				 ('MySQL vs. YourSQL','In the following database comparison ...'),
				 ('MySQL Security','When configured properly, MySQL ...');

		③、如何使用全文索引

			错误用法：“select * from articles where body like "%database%";”，【这个语句是不会用到全文索引的】。
			证明：
			     “explain select * from articles where body like "%database%"\G;”，该语句执行结果可看到。

			正确用法：“SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('database');”，【可以】。
			证明：
			     “explain SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('database')\G;”，执行结果可看到。

		④、全文索引的说明：
		
			1>、在mysql中，全文索引 fulltext 索引 只 针对 myisam 生效。
		
			2>、mysql自己提供的全文索引 fulltext 目前只针对英文字母生效。sphinx（coreseek）技术处理中文

			3>、使用方法是：match(表的字段名1,表的字段名2,...) against("关键字");
				如：“SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('database');”

			4>、fulltext全文索引有一个  停止词。
				对一些常用的词和字符，不会去创建全文索引，这些词呢就叫 “停止词”。
				如：下面的“AGAINST ('a') ”里面的“a”。

				如：执行 “select  MATCH (title,body) AGAINST ('database') from articles;”，
					得到的是一个匹配度表。

				    执行 “select  MATCH (title,body) AGAINST ('a') from articles;”，
					得到的结果是一个匹配度表，所有数据均为：0。

	   1.4、唯一索引添加
		概念：当表的某列被指定为 unique 约束时，这列就是唯一索引。
		
		第①种创建方式：（直接在建表的时候指定unique）
		       建个表：create table ddd(
					id int primary key auto_increment,
					name varchar(32) unique
				);
			       这时字段 name 列就是一个唯一索引了。

		       注意：这个表ddd里面的name是一个唯一索引。
			     但是name列的值可以为 null，并且可以有多个，
			     但是name列的值只允许有一个 '' 空字符串，

				可以用“insert into ddd values(1,null);”,
				      “insert into ddd values(2,null);”
				进行测试。
				可以用“insert into ddd values(1,'');”,
				      “insert into ddd values(2,'');”
				进行测试。

		第②种创建方式：（先建表，然后再去创建唯一索引unique）
			建个表：create table eee(
					id int primary key auto_increment,
					name varchar(32) 
				);
				这时，没有unique唯一索引。

			后添加unique唯一索引：
			语法：“create unique index 索引名 on 表名 (列名或字段名)”。
			
			给eee表中name字段添加unique唯一索引：“create unique index na on eee (name);”	
			可用“show index from eee\G;”来查看
				
		





	2、查询索引（共三种方法），如下：

	   2.1、desc 表名; 【 该方法的缺点：不能显示索引名 】

	   2.2、show index(es) from 表名\G;

	   2.3、show keys from 表名\G;【 该方法与2.2方法是一样的 】

	3、删除索引

	   3.1：删除普通索引：

	   	语法：alter table 表名 drop index 索引名。
		     如“alter table eee drop index na;”。

	   3.2：删除主键索引：（注意：当表的主键有“auto_increment”时，需要先删除“auto_increment”，然后才能删除主键索引）
		语法：
　		     alter table 表名 change 主键字段名 主键字段名 int(10)；//删除自增长
　　		     alter table 表名 drop primary key；//删除主建

			如：eee表的主键字段为“id”,主键“id”有属性“auto_increment”,
			    故而需要先删除主键“id”的“auto_increment”,然后再删除主键索引。
			    删除eee表的主键id语句如下面两句：
			    	“alter table eee change id id int(10);”，
			  	“alter table eee drop primary key;”。

			    执行完上面两句，然后再执行：“show index from eee\G;”语句可以查看删除结果。
				
		

	4、修改索引

	   一般做法：先删除索引，再创建新的索引。


【为什么创建索引后，查询速度会变快呢，原因是因为它采用的是bitree二叉树算法。】

	5、索引使用的注意事项

	   5.1、索引的代价：

		①：会占用磁盘空间,如：“my.ini”配置文件的“datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"”目录
			下的“temp”目录下，如我的emp表数据，它分别是“emp.MYD”、“emp.MYI”、“emp.frm”三个文件，
			“emp.MYI”就是emp表的索引文件，它将近100m了。

		②：对dml（insert增加、update修改、delete删除）操作有影响，说白了，就是“增删改”操作会变慢。
			【为什么dml会变慢呢？-》原因：数据dml之后，二叉树需要进行重整或者重排，会去维护索引文件，如：“emp.MYI”就是emp表的索引文件】

	   5.2、在上述第“五”大步中的第“1”步创建的部门表中，增加几条部门的数据。

		①、利用存储过程向dept表插入数据：

			delimiter $$
			drop procedure insert_dept $$
			create procedure insert_dept(in start int(10),in max_num int(10))
			begin
			declare i int default 0;
			set autocommit=0;
			repeat
			set i=i+1;
			insert into dept values((start+i),rand_string(10),rand_string(8));
			until i=max_num
			end repeat;
			commit;
			end $$
		②、调用存储过程插入数据：

			delimiter ;//将上步中的结束符“$$”改为“;”
			call  insert_dept(100,10);
	【注意：执行上面调用存储过程可能会报这样的错误：ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)】
	【解决：进入mysql控制台，执行命令：SET GLOBAL log_bin_trust_function_creators = 1;即可】

		③、给dept表创建一个主键：alter table dept add primary key (deptno);

		④、给dept表创建一个联合索引（即给“dname”和“loc”字段加同一个索引）

			alter table dept add index myind (dname,loc);
			说明：如果表中有复合索引（索引作用在多列上），此时注意：

			索引使用的注意情况：

				1、对于创建的多列索引，只要查询条件使用了最左边的列，索引一般都会被使用。
				       如“alter table dept add index myind (dname,loc);”，dname就是最左边的列，loc是最右边的列。
				       
				       如果这样查询“select * from dept where loc='aa';”，这时候索引是不会生效的；可以通过
					  “explain select * from dept where loc='aa'\G;”来查看到执行结果，索引未被使用。
   
				       如果这样查询“select * from dept where dname='aa';”，这时候索引是生效的；可以通过
					  “explain select * from dept where dname='aa'\G;”来查看到执行结果，索引已经被使用。
				       可对比二次执行结果。

【注意】：explain可以帮助我们在不真正执行某个sql语句时，就知道mysql怎样执行，这样有利于我们去分析sql指令。
		
				2、对于使用like的查询，查询如果是“%aa”就不会使用索引，如果是“aa%”就会使用索引。
   
				       如果这样查询“select * from dept where dname like 'aa%';”，这时候索引是生效的；可以通过
					  “explain select * from dept where dname like 'aa%'\G;”来查看到执行结果，索引已经被使用。
				           
				       如果这样查询“select * from dept where dname like 'aa';”，这时候索引是生效的；可以通过
					  “explain select * from dept where dname like 'aa'\G;”来查看到执行结果，索引已经被使用。
				       
				       如果这样查询“select * from dept where dname like '%aa';”，这时候索引是不会生效的；可以通过
					  “explain select * from dept where dname like '%aa'\G;”来查看到执行结果，索引未被使用。

					对比查询结果可知，like查询条件前面加“%”或者“_”,索引不会被用到，“_”代表任意一个字符。
					如果一定要这样使用，可用全文索引来解决这个问题。

				3、如果查询条件中有or，有的条件不带索引，即使其中其他条件带索引，也不会使用。
				       换言之，只有当or两侧所有的字段都建立索引，才会使用索引，即缺一个字段不带索引，就不会使用索引。
				       
					如“select * from dept where dname='aa' or loc='aa';”不会使用索引，因为，loc为复合索引的最右边的列。    
					  “explain select * from dept where dname='aa' or loc='aa'\G;” 可查看执行结果，索引未被使用。
				       
					如“select * from dept where dname='aa' or deptno='aa';”使用索引，因为，dname为复合索引的最左边的列，deptno建立了主键索引。    
					  “explain select * from dept where dname='aa' or deptno='aa'\G;” 可查看执行结果，索引被使用。

				4、如果列类型是字符串类型，那么在条件中要将该字段的值用引号引起来，否则不会使用索引。
				       
					如“select * from dept where dname=11;”不会使用索引，dname为字符串类型，其值未用引号引起来。    
					  “explain select * from dept where dname=11\G;” 可查看执行结果，索引未被使用。
				       				       
					如“select * from dept where dname='11';”使用索引，dname为字符串类型，其值用引号引起来了。  
					  “explain select * from dept where dname='11'\G;” 可查看执行结果，索引被使用。

				5、如果mysql自己估计全表扫描比使用索引快，就不会使用索引。
				       
					
				      

	6、在哪些列即字段上适合添加索引

	   6.1、在 较频繁的 作为 查询条件 的字段上，应该创建索引。
		如：“select * from emp where empno=1000000;”；
			在做查询时，字段empno比较频繁的作为查询条件，那么就适合给empno创建索引。

	   6.2、唯一性太差的字段不适合单独创建索引，即使它被频繁的作为查询条件
		如：“select * from emp where sex='男';”；
			建索引的目的是为了形成 “二叉树”，这里的sex字段就不适合创建索引了。

	   6.3、更新非常频繁的字段不适合创建索引。
		如：“select * from emp where logincount=1;”，字段logincount的意义为 统计登录次数。

	   6.4、不会出现在where查询语句中的字段，不要创建索引。

	   总结：满足以下条件的字段，才应该创建索引

		a、肯定在where查询条件中使用，而且是经常使用；
		b、该字段的值有多个，并不仅仅是唯一的几个值，如：性别“sex”；
		c、字段内容不是频繁变化的，如：统计登录次数“logincount”；

	7、如何查看索引的使用情况：
		“show status like 'Handler_read%';”,这个值越高，说明这个索引的使用率越高。
		执行“show status like 'Handler_read%';”得到的结果中“Handler_read_key”的值越高越好；
							 得到的结果中“Handler_read_rnd_next”值越高，说明查询效率越低。

三、常用sql优化

	1、大批量插入数据（mysql管理员）

		①、对于mylsam(先禁用索引，然后插入数据，最后启用索引)：
			1、alter table 表名 disable keys;
			2、插入数据语句;
			3、alter table 表名 enable keys;

		②、对应innodb
			1、将要导入的数据按照主键排序;
			2、set unique_checks=0;//关闭唯一性校验
			3、set autocommit=0;//关闭自动提交

	2、sql语句的小技巧

		1、在使用 group by 分组查询的时候，默认分组后还会进行排序，这样可能会降低速度，“group by”不会使用到索引。
		
			如“explain select * from dept group by dname\G;”和
			  “explain select * from dept group by dname order by null\G;”可以对比‘extra’信息。

			发现：在 group by 后面增加 order by null 就可以 防止排序。

		2、有些情况下，可以使用连接来代替子查询，因为使用 join，mysql不需要在内存中创建临时表。

			“select * from dept,emp where dept.deptno=emp.deptno;”【简单处理方式】
			“select * from dept left join emp on dept.deptno=emp.deptno;”【左外连接，更好】

		3、如何选择mysql的存储引擎

			①、【myisam】 存储：如果表对 【事务】 要求不高，同时是以 【添加】 和 【查询】 为主的，我们考虑使用myisam存储引擎
				比如 bbs 中的帖子表和回复表，可以用myisam存储引擎。

			②、【innodb】 存储：如果表对 【事务】要求高，保存的数据都是重要数据，建议使用innodb存储引擎。
				比如订单表、账户表，用innodb存储引擎。

				问：myisam与innodb的区别：
					1、事务安全：myisam不支持事务，innodb支持事务。
					2、查询和添加速度：myisam快，innodb慢。
					3、支持全文索引：myisam支持全文索引，innodb不支持全文索引。
					4、锁机制：myisam为表级锁，innodb为行级锁。
					5、外键：myisam不支持外键，innodb支持外键。

					【外键】释义：
					如：建立两张表：
						1、建班级表：create table classes(id int primary key,sname varchar(32))engine=innodb;
						   插入一条数据：insert into classes values(1,'aaa');

						2、建学生表(给学生表建立并指定外键)：create table stu(id int primary key,name varchar(32) not null,
								classid int,foreign key (classid) references classes(id))engine=innodb;
						   插入一条数据：insert into stu values(11,'a1',1);成功；
						   再插入一条数据：insert into stu values(12,'a11',2);失败；

						   由上可知：学生表stu里面的字段classid指向班级表classes里面的id；
							     当学生表stu里的classid的值为2，而在班级表classes里id的值没有2，即不存在时，插入失败。


			③、【memory】 存储：如果数据变化频繁、不需要入库，同时频繁的查询和修改，可以考虑用memory引擎。
			                     数据存储在内存中，速度快。
			
				如:
				   建个表：create table userstate(id int primary key,state tinyint)engine=memory;
				   插入两条数据：insert into userstate values(1,0),(2,2);
				   此时查询：select * from userstate;可以查看到两条数据。

				如何证明数据是存储在内存中的呢：
					首先重启电脑的mysql服务；
					然后执行：select * from userstate;可得结果为空。
				由此可验证memory存储数据在内存中。

		4、如果存储引擎是myisam，【谨记】定时进行【碎片整理】。

注：mysql的数据库数据资料默认存放在：C:\ProgramData\MySQL\MySQL Server 5.5\data目录下

			举例说明：
				建个表：create table test100(id int unsigned,name varchar(32))engine=myisam;
				插入3条数据：insert into test100 values(1,'aaa');
					     insert into test100 values(2,'bbb');
					     insert into test100 values(1,'ccc');

					经过上面两步可以看到C:\ProgramData\MySQL\MySQL Server 5.5\data目录下的temp文件夹下
						三个test00不同后缀文件大小均为 【几k】。

				开始【主从复制】：insert into test100 select * from test100;
					      该命令会成次数的增加数据：1变2，2变4，4变8，8变16...的成倍增加。
					
					经过上面的多次主从复制后，可以看到C:\ProgramData\MySQL\MySQL Server 5.5\data目录下的temp文件夹下
						test00.MYD 文件变得【很大】。

					然后执行：delete from test100 where id=3;执行完成以后，可以看到C:\ProgramData\MySQL\MySQL Server 5.5\data目录下的temp文件夹下
						        test00.MYD 文件大小不变，即无论怎样删除，test00.MYD 文件大小是不变的。
						【myisam数据库表的这个毛病如何解决呢】：
							解决办法：我们应该定时对myisam进行整理。指令如下：
								  optimize table test100;【他是清理掉你删除掉的数据】
							执行完上条命令后，C:\ProgramData\MySQL\MySQL Server 5.5\data目录下的temp文件夹下
									test00.MYD 文件变小。



			


*************************************************************************************************************************

七、php定时完成数据库的备份

     1>、手动备份和恢复

	1、手动备份数据库或者数据表的方法：
	   【cmd控制台】
		在 cmd 控制台备份一个数据库的指令：mysqldump -u root -p密码（注：-p与密码之间没有空格） 数据库[表名1  表名2 ...] > 文件路径。
			
			①、比如：(备份temp数据库，将temp数据库备份到 【d:\temp.bak】 的一个指令，在cmd命令行执行)
			     mysqldump  -u root -proot temp > d:\temp.bak //注：temp.bak这个文件名和后缀都随意，爱怎么取就怎么取。
			
			②、比如：你希望备份的是数据库中的某几张表,如想备份temp数据库中的几张表，指令如下：
			     mysqldump  -u root -proot temp aaa  dept emp > d:\temp.biao.bak 
				//注：上行命令中（aaa、dept、emp）为数据库temp中的三张表。
				上面备份三张表的命令在cmd窗口执行完成后，可以看到电脑的d盘出现了一个 temp.biao.bak 文件。

	2、如何使用备份文件恢复数据库或者数据库表的数据。
		【mysql控制台】
		在mysql控制台执行。
		指令：source 文件路径 【在mysql控制台执行】
		      source d:\temp.biao.bak
		如：①、备份：mysqldump  -u root -proot temp aaa  dept emp > d:\temp.biao.bak 【在cmd控制台执行】
		    ②、使用temp数据库，我先删除表aaa：drop table aaa;
		    ③、查看temp数据库的表：show tables;//执行完成后，没有 aaa 这张表
		    ④、恢复数据：source d:\temp.biao.bak;【在mysql控制台执行】
		    ⑤、查看temp数据库的表：show tables;//执行完成后，可以看到有 aaa 这张表
		由上述 5 步，完成数据恢复。

     2>、使用定时器来自动完成
	 原理：把备份数据库的指令，写入bat文件（注：bat文件是一个批处理文件），然后通过任务管理器去定时的调用【bat文件】。

         注意：【我的mysql安装路径为：D:\mysqlApachePhp\mysql\anZhuang\bin】
	       【我的php的安装路径为：D:\mysqlApachePhp\php\php5】

	     1、【第一种方案】：每次备份均会覆盖前一次的备份数据的方案：即只生成一个备份文件。步骤如下：

		实例步骤：
			  ①、我在d盘新建一个mytask.bat文件。【后缀名一定要是“.bat”】
			  ②、我用subline打开mytask.bat文件
			  ③、在打开的mytask,bat文件中写入：
			        D:\mysqlApachePhp\mysql\anZhuang\bin\mysqldump  -u root -proot temp classes > d:\temp.classes.bak 
			       【注意一：在bat文件中写入的命令【必须是绝对路径】】
			       【注意二：在注意一中的bat文件中写入的绝对路径不允许有空格，如果有空格，就要用双引号""将路径包裹起来】
			       【所以：在bat文件中写入的备份命令【mysqldump  -u root -proot temp classes > d:\temp.classes.bak 】前面必须加上我的mysql的安装路径【D:\mysqlApachePhp\mysql\anZhuang\bin\】】
			  ④、首先将先前备份的d盘下面的temp.classes.bak文件删除掉，
			          然后【双击】第③步中自建的mytask.bat文件，可以看到d盘又新生成了一个temp.classes.bak文件。
			      可以得出：自建的有备份内容的mytask.bat文件没有问题。
			  ⑤、把上面形成的mytask.bat文件形成一个任务，并定时调用。
				如我设定的是在2016-04-08日23时54分00秒开始的每隔1分钟调用一次，步骤如下：
					1、打开电脑的“控制面板”->“系统和安全”->“计划任务”->“创建基本任务”->在弹出的“创建基本任务向导”界面的“名称”后随意填入一个名称，我填的是“11111111111”
					       ->“下一步”->选择“每天”->“下一步”->选择设定好“开始”时间和“每隔XX天发生一次”->选择“启动程序”
					       ->“下一步”->在弹窗的“程序和脚本”下点击“浏览”选中刚才建立的“mytask.bat”文件
					       ->一路直到点击“完成”->可以在“任务计划程序”列表中可以看到我前面新建的“111111111111”的任务
						->选中“任务计划程序”中的“111111111111”->右键点击，选择“属性”
						->在弹窗中点击“触发器”->点击“编辑”->在新弹出的窗口勾选“重复任务间隔”并设定“分钟”和“持续时间”，“持续时间”为任务最多执行的时间
						-》点击“确定”。
                                            ・可以在“任务计划程序”中选中“111111111111”右键点击“删除”，删除这个定时任务。					     

					    上面的步骤设定从某年的某天某时某分开始，每隔设定的分钟执行一次数据备份过程。
【注意：如果按上面步骤设定了定时备份，机器却没有按计划运行，则：选中该任务-》右键“属性”-》在弹窗的“条件”下选中“唤醒计算机运行此任务”】
					    【这里的执行后一次会覆盖前一次的数据】。
					    【缺陷】是我只能看到最新的数据，不能看到以前任意时间的数据。不利于我们分时间段进行备份

					    我们更希望看到的是，每次备份的文件名称不同，名称不同的话，每次备份的数据就都保存下来了。

			・・ 由上面五步完成的备份都会覆盖前一次的数据，不利于我们分时间段进行备份

		2、【第二种方案】
			
		    实施步骤：【目标】：形成的备份文件名字为：【年 月 日 时 分 秒.bak】。//注：bak后缀可要可不要，无所谓。
			     ①、首先新建一个php文件，我的新建的php文件为：mytask.php。//注：这个php文件执行备份任务。
				   【注意】 我的“mytask.php”文件放置路径为“D:\www\mytask.php”。
			     ②、打开mytask.php，写入代码：
					<?php
						//执行备份任务--定时备份我们的数据库文件

						//指定时区
						date_default_timezone_set('PRC');

						//定义备份文件名称--bak后缀可要可不要，无所谓
						$backfilename=date("YmdHis",time()).'.bak';

						//定义命令语句
						$command="D:\mysqlApachePhp\mysql\anZhuang\bin\mysqldump  -u root -proot temp classes > d:\\".$backfilename;

    						//执行指令
    						exec($command);
						

					?>

			   ③、在浏览器输入“127.0.0.1”，在列表中执行访问“mytask.php”，即刻生成bak的备份文件，每刷新一次，生成一份。
				【这里为手动刷新页面，备份文件】

				【注意：在浏览器地址栏里面访问“mytask.php”与cmd命令行执行的效果是一样的】
					cmd命令行执行访问“mytask.php”命令如下：
						1、打开cmd窗口
						2、cd D:\mysqlApachePhp\php\php5
						3、d:
						4、php.exe  D:\www\mytask.php   //意义为：让“php.exe”去执行访问“mytask.php”文件
					cmd窗口命令行执行访问“mytask.php”文件，步骤完成。
				
			       【存在问题】这里肯定不能手动刷新页面，而要服务器自动定时备份。即服务器定时自动调用上面的php文件，才可解决问题。
			
			   ④、解决前三步【存在问题】的方法是：
				   1、将第③步中的cmd命令写入一个bat文件中，我的bat文件命名为“mytask2.bat”,
				   2、打开“mytask2.bat”文件，写入：
					D:\mysqlApachePhp\php\php5\php.exe    D:\www\mytask.php
					【注意：上面一行的路径要写绝对路径】
				   3、然后让服务器去定时执行“mytask2.bat”文件。【第一种方案的第⑤步】。
					如果遇到没有定时运行，可在右键该计划任务的“属性”中配置该计划任务运行条件。

			     

				   【注意：以上的定时备份数据库是windows下面的】
				   【Linux下面是将上面的“mytask2.bat”文件改成“mytask2.sh”等可执行文件，然后采用命令“crontab 0 0 0 0 0 mytask2.sh”即可】

			【注意】：上面的“bat”文件，鼠标双击即可执行，即双击即可完成备份。
**************************************************************************************************************************

八、php完成定时发送邮件的功能

    步骤：

	1、设计新建一个邮件表
		create table maillist(
			id int unsigned primary key auto_increment ,  
			sender varchar(64) not null default '',    //发送人
			geter varchar(64) not null default '',     //接收人
			title varchar(32) not null default '',      //邮件标题
			content varchar(2048) not null default '', //邮件内容
			sendtime int unsigned not null default 0, //邮件发送时间
			flag tinyint unsigned not null default 0 //标志位，标记邮件是否已经发送,0为未发送，发送为1。
		)engine=myisam charset utf8;

		添加两条测试数据：十个小时过后再发送【unix_timestamp() 为mysql内置的返回当前时间戳的函数】
				insert into maillist values (null,'a','b','hello100','abc',unix_timestamp()+10*3600,0) ;
				insert into maillist values (null,'a','c','hello101','abc11',unix_timestamp()+10*3600,0);
				insert into maillist values (null,'a','d','hello301','abc11',unix_timestamp()+30,0);	

	2、写代码
		 思考：怎样定时的去检索哪些邮件该发送了？
		 解决：只能每隔一定时间就去看看哪些邮件该发送了。

		       ①、 新建一个“mailtask.php”文件，模拟邮件发送的思路过程，代码如下：

				<?php
					//模拟发送邮件
	
					//连接数据库
					$link=new mysqli('localhost','root','root','temp');
					if($link->connect_errno){
						die($link->connect_error);
					}
					//设置字符集
					$link->query('SET NAMES latin1');
					//查询
					$links=$link->query("SELECT * FROM maillist where flag=0");
					//var_dump($links);die;
					//取得数组
					$rows=array();
					while($row=$links->fetch_assoc()){
						//$rows[]=$row;
						//取出邮件的发送时间
						$sendtime=$row['sendtime'];
						//如果到时间了，就发送
						if($sendtime<=time()){
							//当需要真实发送邮件时，须将下面一行代码改成真实发送邮件的代码
							echo $row['id'].'号邮件发送了.....<br />';
							//如果发送成功了，将该文件的标志位改为：1
							$sql="update maillist set flag=1 where id={$row['id']}";
							if($link->query($sql)){
								echo "更新数据库成功<br />";
							}
						}else{
							echo "没有邮件发送<br />";
						}
		
					}
	
					$links->free();
					$link->close();

				?>


			②、真实发送邮件。利用php中的【mail函数】发送邮件。
					  实际上，我们可以用PHPMailer类，这个类是别人写的，然后发到网上的。我们使用它来完成邮件发送。

			    1、 要正确的使用PHPMailer类发送邮件，需要满足如下条件：
				1>、发送邮件的服务器是能上网的，即本机可以联网。
				2>、需要搭建自己的 【smtp（smtp协议是邮件发送协议，通用的邮件发送协议）/pop3（pop3协议是邮件接收协议，通用的邮件接收协议）】邮件服务器。
					搭建自己的邮件服务器步骤：
					    下载一个邮件服务器，我下的是：遥志邮件服务器。

						安装是傻瓜式安装，一步一步走下去就行了；

						安装向导的配置： 1.1、第一步：选择Microsoft Access，这个数据库，在安装office的时候，就已经自带了；SQl server的话，还要自己另外安装。
								1.2、第二步：去掉“启用Webmail”；
								1.3、第三步：配置：再打开的遥志邮件服务器界面点击菜单栏“设置”->“邮箱域名”，在弹窗的“域名名称”后填入域名：我的ip是“192.168.0.103”，点击“下一步”；
								1.4、第四步：在新弹窗不做修改，点击“下一步”；
								1.5、第五步：将“自动创建组 everyone@192.168.0.103”、“自动创建账号 admin@192.168.0.103”、“自动创建账号 postmaster@192.168.0.103”，三个全部去掉，我们自己创建账号，点击“确定”；
								1.6、第六步：点击“设置”->“服务器设置”，新弹出窗口；
								1.7、第七步：点击“服务器设置”新弹窗的“网络”，去掉“SMTP本地交互同样需要验证”，不然邮件会发送不出去，然后点击“确定”；
								1.8、第八步：点击“服务器设置”新弹窗的“邮件”，将“下次重发间隔”改成你想要的时间间隔，我改成“1分钟”，然后点击“确定”；
											
								至此邮件服务器设置完成，下一步要设置自己的邮件服务器账号：
								1.9、第九步：点击菜单栏“账号”->“新建账号”，会弹出窗口；试用版本只能设置5个账号。
								1.10、第十步：“账号”、“密码”、“用户姓名”，我都设置为“yuxiang”，点击“下一步”，点击“确定”；
								至此，邮箱账号设置完成。下一步，可以写代码了。

			     2、新建一个“mail.php”文件，我的“PHPMailer_v5.1”类包放在“mail.php”文件的同级，“mail.php”写入代码：
						<?php
							//练习用PHPMailer类发送邮件
							require("PHPMailer_v5.1/PHPMailer_v5.1/class.phpmailer.php");
							$mailer=new PHPMailer();
							/*
							 * from 来自于谁
							 * to 发送给谁
							 * cc 抄送
							 * subject 邮件主题
							 * body 邮件正文
							 * 
							 * */
							$cont=<<<mail
	  							 hello,world yyyy;
						mail;
							//echo $cont;
							/*指定mailer的属性---
							 * 相应的属性设置其实是针对遥志服务器来设置的，
	 						 * 事实上我们做的是将邮件发送给遥志邮件服务器，然后遥志再发送给指定的收件人
	 						 * */
							$mailer->CharSet='utf-8';
							$mailer->ContentType='text/html';//指定内容类型为html，charset才能起作用
							$mailer->Encoding='base64';//防止服务器中继时，服务器接受的编码不一致带来的问题
							$mailer->From='yuxiang@192.168.0.103';//我的本地ip为：192.168.0.103,我的遥志邮件服务器账号密码用户名称均是：yuxiang
							$mailer->FromName='yuxiang';
							$mailer->Subject='一个问候。你好，陌生人';
							$mailer->Body=$cont;
							//设置一下语言包i
							$mailer->SetLanguage("zh_cn");
							//增加收件人地址--可以给多个人发，只需将：$mailer->AddAddress("yuxiang438400@126.com",'xiaoyu');复制多份，更改收件人即可
							$mailer->AddAddress("yuxiang438400@126.com",'xiaoyu1');
							$mailer->AddAddress("418404572@qq.com",'xiaoyu2');
							if($mailer->Send()){
								echo "发送邮件成功，ok";
							}else{
								echo "发送邮件失败";
							}
	
						?>
	
						通过浏览器访问“mail.php”文件，我发送的两份邮件，邮件发送成功。但【有个问题：无论是谁访问“mail.php”文件都能发送邮件】。
						解决这个问题的方法：配置 “php.ini”文件，启用“mail.php”文件中设定的账号“yuxiang@192.168.0.103”的密码验证。
							配置“php.ini”：打开“php.ini”文件，找到“[mail function]”，里面有发送邮件的各项配置，将“sendmail_from”注释打开，并将其后的值改为自己的账号“yuxiang@192.168.0.103”，
                            							即“sendmail_from = yuxiang@192.168.0.103”。
										如果要允许多个账号可以发送，可以将“sendmail_from = yuxiang@192.168.0.103”在“php.ini”中复制多份。



**********************************************************************************************************************************
九、表的分割技术

    1、水平分割：

	有一个表，有海量的数据，怎么办？
	比如：QQ的登陆表“QQlogin”有5亿条数据，现在将这张表分割为3张表，表的结构不变，仅仅是数据分别存进三张表里。
	      这样办：将“QQlogin”表分为“QQlogin0”、“QQlogin1”、“QQlogin2”，三张表。
		      “QQlogin0”表存放“用户的id%3=0”的用户；
		      “QQlogin1”表存放“用户的id%3=1”的用户；
		      “QQlogin2”表存放“用户的id%3=2”的用户；	
	我们对上面分割完的三张表的写入与读写操作，在一个控制器里面操作。
	我们新建一个UserController.php文件，该控制器文件的任务：1、添加用户；2、验证用户。
	模拟过程：
		 ①、在数据库“temp”中建立三张表：qqlogin0、qqlogin1、qqlogin2。
			create table qqlogin0(id int primary key ,name varchar(32),pwd varchar(32));
			create table qqlogin1(id int primary key ,name varchar(32),pwd varchar(32));
			create table qqlogin2(id int primary key ,name varchar(32),pwd varchar(32));


		 ②、添加用户。我们在添加用户时，各个用户的id应该确定下来，通常我们可以使用一个辅助表uuid表，uuid表可以帮助我们生成一个编号。
			create  table uuid(id int unsigned primary key auto_increment);

		 ③、新建一个“UserController.php”文件，其目的是对上面建立的三张表进行对应数据的添加和查询。
		     写入：
			  <?php
	
				//添加用户
	 			function add(){
				//连接数据库
				$link=new mysqli('localhost','root','root','temp');
				if($link->connect_errno){
					die($link->connect_error);
				}
				//设置字符集
				$link->query('SET NAMES latin1');
				//获取uuid表的id-》就是QQ号。
				$sql="insert into uuid values(null)";
				if($links=$link->query($sql)){
					//向uuid表插入一条数据时，马上获得该数据的id。
					$uuid=mysqli_insert_id($link);
					//设定表名
					$tablename="qqlogin".($uuid%3);
					//向对应的qqlogin表插入数据
					$sql="insert into ".$tablename." values ($uuid,'a','a')";
					if($links=$link->query($sql)){
						echo "添加成功".$tablename;
					}
			
				}else{
					echo "添加失败";
				}	
				$links->free();
				$link->close();
			}

				//add();
				//查询表数据
				function show(){
					//连接数据库
					$link=new mysqli('localhost','root','root','temp');
					if($link->connect_errno){
						die($link->connect_error);
					}
					//设置字符集
					$link->query('SET NAMES latin1');
					//获得用户的id
					$uuid=intval($_GET['id']);
					//var_dump($id);
					//获得表名
					$tablename="qqlogin".($uuid%3);
					//echo $tablename;
					//查询数据
					$sql="select * from  ".$tablename." where id='$uuid'";
					$links=$link->query($sql);
					//取得数组
					$rows=array();
					while($row=$links->fetch_assoc()){
						$rows=$row;
					}
					if($rows){
						echo "<pre>";
						echo $tablename.'表里的数据是：';
						print_r($rows);
					}else{
						echo "没有这条数据";
					}
		
				}
	
				show();	
			?>

		【分享一句】：我们在提供检索时，应该根据业务的需求，找到分表的标准，并在检索页面，约束用户的检索方式并配合好分页。

    2、垂直分割

	原理：某个表的某些字段，这些字段在查询的时候，并不是经常关心的，但是数据量很大，我们建议大家可以把这些字段提取出来放到另外的一张表中，以提高效率，新表与原来的表要建立关联关系。
	比如：1、有一张【考试结果表】，表里字段有：考试id、学生编号stunum、考试的题目编号questionid、学生的答案answer(text)【内容很大】、这道题目的得分grade；
	      2、还有一张【问题表】：问题id、问题内容question；
	      3、比如你的代码想要查出： 1号 学生的 20号 题的得分情况。
			在查的时候，我们关心的是这道题的得分情况 grade，而并不会去关心这道题的答案 answewr 是什么。
			每次在查得分的时候，虽然我们不去查 答案answer 是什么，但是由于answer很大并且在表里，他就会拖慢我们的查询速度。
			我们的解决方法是：把我们不关心的【考试结果表】里的 answer 取出来，放入第三张表 【学生答案表】里，并且将【学生答案表】和【考试结果表】建立关联联系。
				这时：【学生答案表】的字段：考试id、学生的编号、考试题目的id、学生的答案answer。
				      【考试结果表】里的字段：学生的答案answer，就没有必要存在了，可在这张表里删掉。
	这就是我们的垂直分割！
	
***************************************************************************************************************************

十、如何优化mysql的配置
	主要是修改“my.ini”文件

	1、“max_connections=100”->并发数。mysql默认为100，其实mysql的最大并发数为2000左右。

	2、“query_cache_size=0”->查询缓存的大小，

	3、最重要的参数就是内存，我们用的innodb存储引擎，

		innodb_additional_mem_pool_size=3M
		innodb_buffer_pool_size=107M

	4、对于myisam引擎，
	
		key_buffer_size=55M

	当然调整参数还要看状态，用“show status”语句可以查看当前状态，以决定调整哪些参数。

	5、如果你的机器内存超过 4G，那么应当采用64位操作系统和64位mysql。

	6、mysql的服务器的端口在“my.ini”中可以更改，
		如：我的端口改为：
				[mysqld]

				# The TCP/IP Port the MySQL Server will listen on
				port=3307

		那么，我在php代码中连接mysql的时候需要指定端口：
			$con=mysqli_connect('127.0.0.1','root','root','temp'，3307);
	

********************************************************************************************************************

十一、读写分离
	原理：如果数据库的压力很大，一台机器支撑不了，可以用 mysql复制 实现多台机器同步，将数据库的压力分散。



*********************************************************************************************************************

十二、mysql的增量备份

	1、定义：mysql数据库会以二进制的形式，自动把用户对mysql的操作，记录到文件中。他会自动来完成这个事情。
		  不需要我们做定时器了，只要启用了增量备份，他就会自动的把对mysql的操作记录到文件中。
		  当用户希望恢复的时候，用户可以用备份文件进行恢复。

		  1、增量备份会记录哪些操作呢？->dml（update、delete、add）语句、创建表的语句。不会记录select语句。

		  2、他会记录那些东西呢？->a：操作语句本身；b：操作的时间；c：操作的位置position。

	2、实例【如何进行增量备份和恢复】
		备份步骤如下：
			（1）、配置“my.ini”文件 或者 “my.cof”文件，以启用 二进制备份即增量备份。
				在“my.ini”文件中加入：
							[mysqld]

							# The TCP/IP Port the MySQL Server will listen on
							port=3306
							#这里指定把备份文件放在那个目录下,我的放在“D:/beiFen”目录下。
							#我的备份文件名称为“yuxiang”。
							log-bin=d:/beiFen/yuxiang

			 （2）、重启mysql。重启mysql服务后，发现“D:/beiFen”目录下多了两个文件“yuxiang.000001”、“yuxiang.index”。
						其中：“yuxiang.000001”就是备份文件，很重要，将来的各种操作都会保存在这个文件中。
						      “yuxiang.index”是一个存备份文件名称的索引文件，记录有多少个备份文件，没有用，不去管它。



			 （3）、可以用【mysqlbinlog（在mysql的bin目录下有这个程序，我的本机在“D:\mysqlApachePhp\mysql\anZhuang\bin”目录下有个“mysqlbinlog.exe”文件）】程序来查看备份文件“yu.000001”的内容。
					进入“cmd”控制台，命令：mysqlbinlog 备份文件的绝对路径。
					我的“cmd”命令为：“mysqlbinlog D:\beiFen\yuxiang.000001”。成功看到内容。
				可以得出结论：mysql会对每一个操作分配一个位置（end_log_pos）和一个时间(TIMESRAMP)。我们可以根据位置或者时间来进行恢复。

		上面三步至此，备份完成。

		【根据时间点】的恢复步骤如下：
			（1）、接着上面备份操作的步骤之后，我删除了表“drop table ddd;”,执行“show tables;”->“ddd”表确实没有了。
				
			（2）、打开“cmd”命令窗口，执行“mysqlbinlog D:\beiFen\yuxiang.000001”可以得到上面“drop table ddd;”操作的时间：“SET TIMESTAMP=1460559007/*!*/;”，
				其中“TIMESTAMP=1460559007”即为删除表操作的时间点。

			（3）、执行恢复的命令说明：在cmd命令行执行
				1、打开 cmd 窗口

				2、在cmd窗口，切换到mysql的安装目录：cd D:\mysqlApachePhp\mysql\anZhuang\bin
							 	    d:

				3、下面两个命令：一个【向前恢复】，一个【向后恢复】。在cmd窗口，

				   命令一：“mysqlbinlog --stop-datetime="时间点" 以哪个备份文件来恢复的备份文件绝对路径 | mysql -uroot -p”
				   说明：  上面一行命令中含有“stop”的意思是：执行备份的位置，从备份文件开始备份的位置到上面命令行中“"时间点"”位置之前的所有操作均会恢复；
					    即：恢复到上面命令行中“"时间点"”之前的状态。
				   
				   命令二：“mysqlbinlog --start-datetime="时间点" 以哪个备份文件来恢复的备份文件绝对路径 | mysql -uroot -p”
				   说明：  上面一行命令中含有“start”的意思是：执行备份的位置，从备份文件在上面命令行中“"时间点"”位置之后的所有操作均会恢复；
					    即：恢复到上面命令行中“"时间点"”之后的状态。

					【注】：上面两个命令的"时间点"格式为："2016-04-14 00:12:58"。


				   我执行：mysqlbinlog --stop-datetime="2016-04-14 00:12:58" d:/beiFen/yuxiang.000001 | mysql -uroot -p
					  回车，输入密码root，报错：table "temp.ddd" doesnot exist.

				4、到mysql命令窗口，到“temp”数据库下创建一个名为“ddd”的空表。

				5、回到cmd命令窗口，执行上面第 3 步，没有报错，回到mysql命令窗口，搜索以及查询ddd表的数据，成功。

		【根据时间段】的恢复步骤如下：
			（1）、接着上面备份操作的步骤之后，我删除了表“drop table ddd;”,执行“show tables;”->“ddd”表确实没有了。
				
			（2）、打开“cmd”命令窗口，执行“mysqlbinlog D:\beiFen\yuxiang.000001”可以得到上面“drop table ddd;”操作的时间：“SET TIMESTAMP=1460559007/*!*/;”，
				其中“TIMESTAMP=1460559007”即为删除表操作的时间点。

			（3）、执行恢复的命令说明：在cmd命令行执行
				1、打开 cmd 窗口

				2、在cmd窗口，切换到mysql的安装目录：cd D:\mysqlApachePhp\mysql\anZhuang\bin
							 	    d:

				3、在cmd窗口：

				   命令：“mysqlbinlog --start-datetime="开始时间点" --stop-datetime="结束时间点" 以哪个备份文件来恢复的备份文件绝对路径 | mysql -uroot -p”
				   说明：  上面一行命令中含有“start”的意思是：执行备份的开始时间点，“stop”的意思是：执行备份的结束时间点。
				   
					【注】：上面命令的两个"时间点"格式为："2016-04-14 00:12:58"。


				   我执行：mysqlbinlog --start-datetime="2016-04-14 00:22:24"  --stop-datetime="2016-04-14 00:22:58" d:/beiFen/yuxiang.000001 | mysql -uroot -p
					  回车，输入密码root，无错。

				
				4、回到mysql命令窗口，搜索以及查询ddd表的数据，成功。




		【根据位置点】的恢复步骤如下：
			（1）、接着上面备份操作的步骤之后，我删除了表“drop table ddd;”,执行“show tables;”->“ddd”表确实没有了。
				
			（2）、打开“cmd”命令窗口，执行“mysqlbinlog D:\beiFen\yuxiang.000001”可以得到上面“drop table ddd;”操作的时间：“SET TIMESTAMP=1460559007/*!*/;”，
				其中“TIMESTAMP=1460559007”即为删除表操作的时间点。


			（3）、执行恢复的命令说明：在cmd命令行执行
				1、打开 cmd 窗口

				2、在cmd窗口，切换到mysql的安装目录：cd D:\mysqlApachePhp\mysql\anZhuang\bin
							 d:

				3、下面两个命令：一个【向前恢复】，一个【向后恢复】。在cmd窗口，

				   命令一：“mysqlbinlog --stop-position="位置" 以哪个备份文件来恢复的备份文件绝对路径 | mysql -uroot -p”
				   说明：  上面一行命令中含有“stop”的意思是：执行备份的位置，从备份文件开始备份的位置到上面命令行中“"位置"”位置之前的所有操作均会恢复；
					    即：恢复到上面命令行中“"位置"”之前的状态。
				   
				   命令二：“mysqlbinlog --start-position="位置" 以哪个备份文件来恢复的备份文件绝对路径 | mysql -uroot -p”
				   说明：  上面一行命令中含有“start”的意思是：执行备份的位置，从备份文件在上面命令行中“"位置"”位置之后的所有操作均会恢复；
					    即：恢复到上面命令行中“"位置"”之后的状态。


				   我执行：mysqlbinlog --stop-position="486" d:/beiFen/yuxiang.000001 | mysql -uroot -p
					  回车，输入密码root，报错：table "temp.ddd" doesnot exist.

				4、到mysql命令窗口，到“temp”数据库下创建一个名为“ddd”的空表。

				5、回到cmd命令窗口，执行上面第 3 步，没有报错，回到mysql命令窗口，搜索以及查询ddd表的数据，成功。

				

		【根据位置段】的恢复步骤如下：
			（1）、接着上面备份操作的步骤之后，我删除了表“drop table ddd;”,执行“show tables;”->“ddd”表确实没有了。
				
			（2）、打开“cmd”命令窗口，执行“mysqlbinlog D:\beiFen\yuxiang.000001”可以得到上面“drop table ddd;”操作的时间：“SET TIMESTAMP=1460559007/*!*/;”，
				其中“TIMESTAMP=1460559007”即为删除表操作的时间点。


			（3）、执行恢复的命令说明：在cmd命令行执行
				1、打开 cmd 窗口

				2、在cmd窗口，切换到mysql的安装目录：cd D:\mysqlApachePhp\mysql\anZhuang\bin
							 d:

				3、下面命令：恢复某个位置段的数据。在cmd窗口，

				   命令：“mysqlbinlog --start-position="开始位置" --stop-position="结束位置" 以哪个备份文件来恢复的备份文件绝对路径 | mysql -uroot -p”
				   说明：  上面一行命令中含有“start”的意思是：开始恢复的位置，“stop”的意思是：结束恢复的位置，两个位置之间的数据会恢复
					  
				   
				 


				   我执行：mysqlbinlog --start-position="42271" --stop-position="43307" d:/beiFen/yuxiang.000001 | mysql -uroot -p
					  回车，输入密码root，无错。

				
				4、回到mysql命令窗口，搜索以及查询ddd表的数据，成功。


		3、如果每天都会生成大量的二进制日志，如果这些日志长时间不清理的话，将会对磁盘带来很大的浪费。
		 	所以定期清理日志是DBA维护mysql的一个重要工作。

		   在mysql窗口执行命令：“RESET MASTER” -> 删除全部日志。两种查看结果方法：
			1、我在mysql窗口执行“reset master;”之后，可以回到“D:\beiFen”目录看到所有的文件大小均变为 1kb。
			2、在cmd窗口，切换到mysql的安装目录：cd D:\mysqlApachePhp\mysql\anZhuang\bin
							    d:
							    mysqlbinlog D:\beiFen\yuxiang.000001
			   可以看到，备份文件的操作内容为空。

		4、【expire_logs_days】：此参数设置日志的过期天数，过期的日志将会被自动删除。
			这有利于我们管理日志的工作量，需要修改配置“my.cof”或者“my.ini”文件。
			即：我打开“my.ini”文件，找到里面的“[mysqld]”模块，
				在“[mysqld]”下面添加“expire_logs_day=3” -> 即将过期时间设置为3天，
					这里我们设置日志保存时间为3天，3天之后过期的日志将会被自动删除。

		5、例子：如何在工作中将全备份和增量备份配合起来使用。

			方案：每周一进行全备份：mysqldump，然后启用增量备份，把增量备份的过期时间设置为：大于等于 7。
				增量备份不需要启用定时器。
			如果数据库崩溃，就可以通过时间和位置来恢复（需要去看增量日志）。
					
			

******************************************************************************************************************************************************************************

mysql 主从复制   详见：http://369369.blog.51cto.com/319630/790921/

具体步骤如下：

1、主从服务器分别作以下操作：

  1.1、版本一致
  1.2、初始化表，并在后台启动mysql
  1.3、修改root的密码

2、修改主服务器master:

   #vi /etc/my.cnf
       [mysqld]
       log-bin=mysql-bin   //[必须]启用二进制日志
       server-id=222      //[必须]服务器唯一ID，默认是1，一般取IP最后一段

3、修改从服务器slave:

   #vi /etc/my.cnf
       [mysqld]
       log-bin=mysql-bin   //[不是必须]启用二进制日志
       server-id=226      //[必须]服务器唯一ID，默认是1，一般取IP最后一段

4、重启两台服务器的mysql

   /etc/init.d/mysql restart

5、在主服务器上建立帐户并授权slave:

   #/usr/local/mysql/bin/mysql -uroot -pmttang  
   mysql>GRANT REPLICATION SLAVE ON *.* to 'mysync'@'%' identified by 'q123456'; //一般不用root帐号，&ldquo;%&rdquo;表示所有客户端都可能连，只要帐号，密码正确，此处可用具体客户端IP代替，如192.168.145.226，加强安全。【注】：这里的 'mysync'是主服务器的用户名， 'q123456'是主服务器的密码。

6、登录主服务器的mysql，查询master的状态

   mysql>show master status;
   +------------------+----------+--------------+------------------+
   | File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
   +------------------+----------+--------------+------------------+
   | mysql-bin.000004 |      308 |              |                  |
   +------------------+----------+--------------+------------------+
   1 row in set (0.00 sec)
   注：执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化

7、配置从服务器Slave：

   mysql>change master to master_host='192.168.145.222',master_user='mysync',master_password='q123456',
         master_log_file='mysql-bin.000004',master_log_pos=308;   //注意不要断开，308数字前后无单引号。

   Mysql>start slave;    //启动从服务器复制功能

8、检查从服务器复制功能状态：

   mysql> show slave status\G

   *************************** 1. row ***************************

              Slave_IO_State: Waiting for master to send event
              Master_Host: 192.168.2.222  //主服务器地址
              Master_User: mysync   //授权帐户名，尽量避免使用root
              Master_Port: 3306    //数据库端口，部分版本没有此行
              Connect_Retry: 60
              Master_Log_File: mysql-bin.000004
              Read_Master_Log_Pos: 600     //#同步读取二进制日志的位置，大于等于Exec_Master_Log_Pos
              Relay_Log_File: ddte-relay-bin.000003
              Relay_Log_Pos: 251
              Relay_Master_Log_File: mysql-bin.000004
              Slave_IO_Running: Yes    //此状态必须YES
              Slave_SQL_Running: Yes     //此状态必须YES
                    ......

注：Slave_IO及Slave_SQL进程必须正常运行，即YES状态，否则都是错误的状态(如：其中一个NO均属错误)。

以上操作过程，主从服务器配置完成。
 
9、主从服务器测试：

主服务器Mysql，建立数据库，并在这个库中建表插入一条数据：

  mysql> create database hi_db;
  Query OK, 1 row affected (0.00 sec)

  mysql> use hi_db;
  Database changed

  mysql>  create table hi_tb(id int(3),name char(10));
  Query OK, 0 rows affected (0.00 sec)
 
  mysql> insert into hi_tb values(001,'bobu');
  Query OK, 1 row affected (0.00 sec)

  mysql> show databases;
   +--------------------+
   | Database           |
   +--------------------+
   | information_schema |
   | hi_db                |
   | mysql                |
   | test                 |
   +--------------------+
   4 rows in set (0.00 sec)

从服务器Mysql查询：

   mysql> show databases;

   +--------------------+
   | Database               |
   +--------------------+
   | information_schema |
   | hi_db                 |       //I'M here，大家看到了吧
   | mysql                 |
   | test          |

   +--------------------+
   4 rows in set (0.00 sec)

   mysql> use hi_db
   Database changed
   mysql> select * from hi_tb;           //查看主服务器上新增的具体数据
   +------+------+
   | id   | name |
   +------+------+
   |    1 | bobu |
   +------+------+
   1 row in set (0.00 sec)
 

10、完成：







